# Задача 4. Кэширование для ускорения вычислений
# Создайте декоратор, который кэширует (сохраняет для дальнейшего использования)
# результаты вызова функции и, при повторном вызове с теми же аргументами,
# возвращает сохранённый результат.
# Примените его к рекурсивной функции вычисления чисел Фибоначчи.
# В итоге декоратор должен проверять аргументы, с которыми вызывается функция, и,
# если такие аргументы уже использовались, должен вернуть сохранённый результат
# вместо запуска расчёта.
# Подсказка № 1
# Используйте словарь для хранения кэшированных результатов. Создайте словарь
# внутри декоратора для хранения результатов вызова функции с определёнными
# аргументами. Это позволит быстро проверять, были ли уже вычислены результаты для
# этих аргументов.
# Подсказка № 2
# Внутри функции-обертки проверьте, содержится ли результат для текущих аргументов
# в словаре кэша. Если результат есть, верните его, иначе вызовите декорируемую
# функцию и сохраните результат в кэш.


from functools import cache



def mydecor(func):
    _cache = {}
    # @cache
    def wrapper (num):
        if num not in _cache:
            res = func(num)
            _cache[num] = res
            return res
        else:
            return _cache[num]
    return wrapper




@mydecor
def fib(num):
    print('Рaботает функция', end=' ')
    res =[1,1]
    if num ==1:
        return 1
    if num ==2:
        return res
    for i in range(1,num):
        res.append(res[i-1]+res[i])
    return res


print (fib(10))
print (fib(10))
print (fib(14))
print (fib(10))

